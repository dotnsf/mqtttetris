[{"id":"742c51ad.23eee8","type":"tab","label":"Tetris","disabled":false,"info":""},{"id":"7aa56efb.21d7d8","type":"http in","z":"742c51ad.23eee8","name":"","url":"/controller.js","method":"get","upload":false,"swaggerDoc":"","x":159.5,"y":215.25,"wires":[["4ee4e8c2.df7e28"]]},{"id":"48151757.68eff8","type":"http response","z":"742c51ad.23eee8","name":"","statusCode":"","headers":{},"x":595.5,"y":257.5,"wires":[]},{"id":"4ee4e8c2.df7e28","type":"template","z":"742c51ad.23eee8","name":"JavaScript","field":"payload","fieldType":"msg","format":"javascript","syntax":"plain","template":"/*\n キーボードを入力した時に一番最初に呼び出される処理\ndocument.body.onkeydown = function( e ) {\n  // キーに名前をセットする\n  var keys = {\n    37: 'left',\n    39: 'right',\n    40: 'down',\n    38: 'rotate'\n  };\n\n  if ( typeof keys[ e.keyCode ] != 'undefined' ) {\n    // セットされたキーの場合はtetris.jsに記述された処理を呼び出す\n    keyPress( keys[ e.keyCode ] );\n    // 描画処理を行う\n    render();\n  }\n};\n*/\n\nvar socket;\nvar th = 5; //. しきい値\nvar wsUrl = 'wss://' + location.hostname + '/ws/sensor';\nfunction connect(){\n  socket = new WebSocket(wsUrl);\n  socket.onmessage = function(e) {\n    var sensorData = JSON.parse(e.data);\n    //console.log( sensorData );\n\n    if( sensorData.d.ori.tiltLR >= 50 ){\n      //. 右\n      keyPress( 'right' );\n      render();\n    }else if( sensorData.d.ori.tiltLR <= -50 ){\n      //. 左\n      keyPress( 'left' );\n      render();\n    }else if( sensorData.d.ori.tiltFB >= 50 || sensorData.d.ori.tiltFB <= -50 ){\n      //. 上（回転）\n      keyPress( 'rotate' );\n      render();\n    }else if( sensorData.d.ac.x >= th || sensorData.d.ac.x <= th * -1 || sensorData.d.ac.y >= th || sensorData.d.ac.y <= th * -1 ){\n      //. 下\n      keyPress( 'down' );\n      render();\n    }\n  }\n}\n\n// キーボードが押された時に呼び出される関数\nfunction keyPress( key ) {\n  switch ( key ) {\n  case 'left':\n    if ( valid( -1 ) ) {\n      --currentX;  // 左に一つずらす\n    }\n    break;\n  case 'right':\n    if ( valid( 1 ) ) {\n      ++currentX;  // 右に一つずらす\n    }\n    break;\n  case 'down':\n    if ( valid( 0, 1 ) ) {\n      ++currentY;  // 下に一つずらす\n    }\n    break;\n  case 'rotate':\n    // 操作ブロックを回す\n    var rotated = rotate( current );\n    if ( valid( 0, 0, rotated ) ) {\n      current = rotated;  // 回せる場合は回したあとの状態に操作ブロックをセットする\n    }\n    break;\n  }\n}\n\n// 操作ブロックを回す処理\nfunction rotate( current ) {\n  var newCurrent = [];\n  for ( var y = 0; y < 4; ++y ) {\n    newCurrent[ y ] = [];\n    for ( var x = 0; x < 4; ++x ) {\n      newCurrent[ y ][ x ] = current[ 3 - x ][ y ];\n    }\n  }\n  return newCurrent;\n}\n\n\n\n\n","output":"str","x":390,"y":240,"wires":[["48151757.68eff8"]]},{"id":"5229d1ce.a36748","type":"http in","z":"742c51ad.23eee8","name":"","url":"/mqttws31.js","method":"get","upload":false,"swaggerDoc":"","x":183.5,"y":100.25,"wires":[["e5bfa0d5.65bb4"]]},{"id":"e5bfa0d5.65bb4","type":"template","z":"742c51ad.23eee8","name":"JavaScript","field":"payload","fieldType":"msg","format":"javascript","syntax":"plain","template":"/*******************************************************************************\n * Copyright (c) 2013 IBM Corp.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution. \n *\n * The Eclipse Public License is available at \n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at \n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Andrew Banks - initial API and implementation and/or initial documentation\n *******************************************************************************/\n\n\n// Only expose a single object name in the global namespace.\n// Everything must go through this module. Global Messaging module\n// only has a single public function, client, which returns\n// a Messaging client object given connection details.\n \n/**\n * @namespace Messaging \n * Send and receive messages using web browsers.\n * <p> \n * This programming interface lets a JavaScript client application use the MQTT V3.1 protocol to \n * connect to an MQTT-supporting messaging server.\n *  \n * The function supported includes:\n * <ol>\n * <li>Connecting to and disconnecting from a server. The server is identified by its host name and port number. \n * <li>Specifying options that relate to the communications link with the server, \n * for example the frequency of keep-alive heartbeats, and whether SSL/TLS is required.\n * <li>Subscribing to and receiving messages from MQTT Topics.\n * <li>Publishing messages to MQTT Topics.\n * </ol>\n * <p>\n * <h2>The API consists of two main objects:</h2>\n * The <b>Messaging.Client</b> object. This contains methods that provide the functionality of the API,\n * including provision of callbacks that notify the application when a message arrives from or is delivered to the messaging server,\n * or when the status of its connection to the messaging server changes.\n * <p>\n * The <b>Messaging.Message</b> object. This encapsulates the payload of the message along with various attributes\n * associated with its delivery, in particular the destination to which it has been (or is about to be) sent. \n * <p>\n * The programming interface validates parameters passed to it, and will throw an Error containing an error message\n * intended for developer use, if it detects an error with any parameter.\n * <p>\n * Example:\n * \n * <code><pre>\nclient = new Messaging.Client(location.hostname, Number(location.port), \"clientId\");\nclient.onConnectionLost = onConnectionLost;\nclient.onMessageArrived = onMessageArrived;\nclient.connect({onSuccess:onConnect});\n\nfunction onConnect() {\n  // Once a connection has been made, make a subscription and send a message.\n  console.log(\"onConnect\");\n  client.subscribe(\"/World\");\n  message = new Messaging.Message(\"Hello\");\n  message.destinationName = \"/World\";\n  client.send(message); \n};\nfunction onConnectionLost(responseObject) {\n  if (responseObject.errorCode !== 0)\n    console.log(\"onConnectionLost:\"+responseObject.errorMessage);\n};\nfunction onMessageArrived(message) {\n  console.log(\"onMessageArrived:\"+message.payloadString);\n  client.disconnect(); \n};\t\n * </pre></code>\n * <p>\n * Other programming languages,\n * <a href=\"/clients/java/doc/javadoc/index.html\"><big>Java</big></a>,\n * <a href=\"/clients/c/doc/html/index.html\"><big>C</big></a>.\n */\nMessaging = (function (global) {\n\n    // Private variables below, these are only visible inside the function closure\n    // which is used to define the module. \n\n\tvar version = \"0.0.0.0\";\n\tvar buildLevel = \"@BUILDLEVEL@\";\n\t\n    /** \n     * Unique message type identifiers, with associated\n     * associated integer values.\n     * @private \n     */\n    var MESSAGE_TYPE = {\n        CONNECT: 1, \n        CONNACK: 2, \n        PUBLISH: 3,\n        PUBACK: 4,\n        PUBREC: 5, \n        PUBREL: 6,\n        PUBCOMP: 7,\n        SUBSCRIBE: 8,\n        SUBACK: 9,\n        UNSUBSCRIBE: 10,\n        UNSUBACK: 11,\n        PINGREQ: 12,\n        PINGRESP: 13,\n        DISCONNECT: 14\n    };\n    \n    // Collection of utility methods used to simplify module code \n    // and promote the DRY pattern.  \n\n    /**\n     * Validate an object's parameter names to ensure they \n     * match a list of expected variables name for this option\n     * type. Used to ensure option object passed into the API don't\n     * contain erroneous parameters.\n     * @param {Object} obj User options object\n     * @param {key:type, key2:type, ...} valid keys and types that may exist in obj. \n     * @throws {Error} Invalid option parameter found. \n     * @private \n     */\n    var validate = function(obj, keys) {\n        for(key in obj) {\n        \tif (obj.hasOwnProperty(key)) {       \t\t\n        \t    if (keys.hasOwnProperty(key)) {\n        \t        if (typeof obj[key] !== keys[key])\n        \t\t       throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));\n        \t    } else {\t\n            \t    var errorStr = \"Unknown property, \" + key + \". Valid properties are:\";\n            \t    for (key in keys)\n            \t\t    if (keys.hasOwnProperty(key))\n            \t\t        errorStr = errorStr+\" \"+key;\n            \t    throw new Error(errorStr);\n                }\n        \t}\n        }\n    };\n\n    /**\n     * Return a new function which runs the user function bound\n     * to a fixed scope. \n     * @param {function} User function\n     * @param {object} Function scope  \n     * @return {function} User function bound to another scope\n     * @private \n     */\n    var scope = function (f, scope) {\n        return function () {\n            return f.apply(scope, arguments);\n        };\n    };\n    \n    /** \n     * Unique message type identifiers, with associated\n     * associated integer values.\n     * @private \n     */\n    var ERROR = {\n    \tOK: {code:0, text:\"AMQJSC0000I OK.\"},\n    \tCONNECT_TIMEOUT: {code:1, text:\"AMQJSC0001E Connect timed out.\"},\n        SUBSCRIBE_TIMEOUT: {code:2, text:\"AMQJS0002E Subscribe timed out.\"}, \n        UNSUBSCRIBE_TIMEOUT: {code:3, text:\"AMQJS0003E Unsubscribe timed out.\"},\n        PING_TIMEOUT: {code:4, text:\"AMQJS0004E Ping timed out.\"},\n        INTERNAL_ERROR: {code:5, text:\"AMQJS0005E Internal error.\"},\n        CONNACK_RETURNCODE: {code:6, text:\"AMQJS0006E Bad Connack return code:{0} {1}.\"},\n        SOCKET_ERROR: {code:7, text:\"AMQJS0007E Socket error:{0}.\"},\n        SOCKET_CLOSE: {code:8, text:\"AMQJS0008I Socket closed.\"},\n        MALFORMED_UTF: {code:9, text:\"AMQJS0009E Malformed UTF data:{0} {1} {2}.\"},\n        UNSUPPORTED: {code:10, text:\"AMQJS0010E {0} is not supported by this browser.\"},\n        INVALID_STATE: {code:11, text:\"AMQJS0011E Invalid state {0}.\"},\n        INVALID_TYPE: {code:12, text:\"AMQJS0012E Invalid type {0} for {1}.\"},\n        INVALID_ARGUMENT: {code:13, text:\"AMQJS0013E Invalid argument {0} for {1}.\"},\n        UNSUPPORTED_OPERATION: {code:14, text:\"AMQJS0014E Unsupported operation.\"},\n        INVALID_STORED_DATA: {code:15, text:\"AMQJS0015E Invalid data in local storage key={0} value={1}.\"},\n        INVALID_MQTT_MESSAGE_TYPE: {code:16, text:\"AMQJS0016E Invalid MQTT message type {0}.\"},\n        MALFORMED_UNICODE: {code:17, text:\"AMQJS0017E Malformed Unicode string:{0} {1}.\"},\n    };\n    \n    /** CONNACK RC Meaning. */\n    var CONNACK_RC = {\n   \t\t0:\"Connection Accepted\",\n   \t\t1:\"Connection Refused: unacceptable protocol version\",\n   \t\t2:\"Connection Refused: identifier rejected\",\n   \t\t3:\"Connection Refused: server unavailable\",\n   \t\t4:\"Connection Refused: bad user name or password\",\n   \t\t5:\"Connection Refused: not authorized\"\n    };\n \n    /**\n     * Format an error message text.\n     * @private\n     * @param {error} ERROR.KEY value above.\n     * @param {substitutions} [array] substituted into the text.\n     * @return the text with the substitutions made.\n     */\n    var format = function(error, substitutions) {\n    \tvar text = error.text;\n    \tif (substitutions) {\n    \t  for (var i=0; i<substitutions.length; i++) {\n    \t\tfield = \"{\"+i+\"}\";\n    \t\tstart = text.indexOf(field);\n    \t\tif(start > 0) {\n    \t\t\tvar part1 = text.substring(0,start);\n    \t\t\tvar part2 = text.substring(start+field.length);\n    \t\t\ttext = part1+substitutions[i]+part2;\n    \t\t}\n    \t  }\n    \t}\n    \treturn text;\n    };\n    \n    //MQTT protocol and version        6    M    Q    I    s    d    p    3\n    var MqttProtoIdentifier = [0x00,0x06,0x4d,0x51,0x49,0x73,0x64,0x70,0x03];\n    \n    /**\n     * @ignore\n     * Construct an MQTT wire protocol message.\n     * @param type MQTT packet type.\n     * @param options optional wire message attributes.\n     * \n     * Optional properties\n     * \n     * messageIdentifier: message ID in the range [0..65535]\n     * payloadMessage:\tApplication Message - PUBLISH only\n     * connectStrings:\tarray of 0 or more Strings to be put into the CONNECT payload\n     * topics:\t\t\tarray of strings (SUBSCRIBE, UNSUBSCRIBE)\n     * requestQoS:\t\tarray of QoS values [0..2]\n     *  \n     * \"Flag\" properties \n     * cleanSession:\ttrue if present / false if absent (CONNECT)\n     * willMessage:  \ttrue if present / false if absent (CONNECT)\n     * isRetained:\t\ttrue if present / false if absent (CONNECT)\n     * userName:\t\ttrue if present / false if absent (CONNECT)\n     * password:\t\ttrue if present / false if absent (CONNECT)\n     * keepAliveInterval:\tinteger [0..65535]  (CONNECT)\n     *\n     * @private\n     */\n    var WireMessage = function (type, options) { \t\n        this.type = type;\n        for(name in options) {\n            if (options.hasOwnProperty(name)) {\n                this[name] = options[name];\n            }\n        }\n    };\n    \n    WireMessage.prototype.encode = function() {\n    \t// Compute the first byte of the fixed header\n    \tvar first = ((this.type & 0x0f) << 4);\n    \t\n    \t/*\n    \t * Now calculate the length of the variable header + payload by adding up the lengths\n    \t * of all the component parts\n    \t */\n\n    \tremLength = 0;\n    \ttopicStrLength = new Array();\n    \t\n    \t// if the message contains a messageIdentifier then we need two bytes for that\n    \tif (this.messageIdentifier != undefined)\n    \t\tremLength += 2;\n\n    \tswitch(this.type) {\n    \t    // If this a Connect then we need to include 12 bytes for its header\n\t        case MESSAGE_TYPE.CONNECT:\n\t        \tremLength += MqttProtoIdentifier.length + 3;\n                remLength += UTF8Length(this.clientId) + 2;\n\t\t\t    if (this.willMessage != undefined) {\n\t\t\t    \tremLength += UTF8Length(this.willMessage.destinationName) + 2;\n                    // Will message is always a string, sent as UTF-8 characters with a preceding length.\n\t\t\t\t    var willMessagePayloadBytes = this.willMessage.payloadBytes;\n\t\t\t\t    if (!(willMessagePayloadBytes instanceof Uint8Array))\n\t\t        \t\twillMessagePayloadBytes = new Uint8Array(payloadBytes);\n                    remLength += willMessagePayloadBytes.byteLength +2;\n    \t        }\n                if (this.userName != undefined)\n                    remLength += UTF8Length(this.userName) + 2;\n                if (this.password != undefined)\n                    remLength += UTF8Length(this.password) + 2;\n\t\t\tbreak;\n\n\t\t\t// Subscribe, Unsubscribe can both contain topic strings\n\t        case MESSAGE_TYPE.SUBSCRIBE:\t        \t\n\t        \tfirst |= 0x02; // Qos = 1;\n\t        \tfor ( var i = 0; i < this.topics.length; i++) {\n\t        \t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\n\t        \t\tremLength += topicStrLength[i] + 2;\n\t        \t}\n\t        \tremLength += this.requestedQos.length; // 1 byte for each topic's Qos\n\t        \t// QoS on Subscribe only\n\t        \tbreak;\n\n\t        case MESSAGE_TYPE.UNSUBSCRIBE:\n\t        \tfirst |= 0x02; // Qos = 1;\n\t        \tfor ( var i = 0; i < this.topics.length; i++) {\n\t        \t\ttopicStrLength[i] = UTF8Length(this.topics[i]);\n\t        \t\tremLength += topicStrLength[i] + 2;\n\t        \t}\n\t        \tbreak;\n\n\t        case MESSAGE_TYPE.PUBLISH:\n\t        \tif (this.payloadMessage.duplicate) first |= 0x08;\n\t        \tfirst  = first |= (this.payloadMessage.qos << 1);\n\t        \tif (this.payloadMessage.retained) first |= 0x01;\n\t        \tdestinationNameLength = UTF8Length(this.payloadMessage.destinationName);\n\t        \tremLength += destinationNameLength + 2;\t   \n\t        \tvar payloadBytes = this.payloadMessage.payloadBytes;\n\t        \tremLength += payloadBytes.byteLength;  \n\t        \tif (payloadBytes instanceof ArrayBuffer)\n\t        \t\tpayloadBytes = new Uint8Array(payloadBytes);\n\t        \telse if (!(payloadBytes instanceof Uint8Array))\n\t        \t\tpayloadBytes = new Uint8Array(payloadBytes.buffer);\n\t        \tbreak;\n\n\t        case MESSAGE_TYPE.DISCONNECT:\n\t        \tbreak;\n\n\t        default:\n\t        \t;\n    \t}\n\n    \t// Now we can allocate a buffer for the message\n\n    \tvar mbi = encodeMBI(remLength);  // Convert the length to MQTT MBI format\n    \tvar pos = mbi.length + 1;        // Offset of start of variable header\n    \tvar buffer = new ArrayBuffer(remLength + pos);\n    \tvar byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\n\n    \t//Write the fixed header into the buffer\n    \tbyteStream[0] = first;\n    \tbyteStream.set(mbi,1);\n\n    \t// If this is a PUBLISH then the variable header starts with a topic\n    \tif (this.type == MESSAGE_TYPE.PUBLISH)\n    \t\tpos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\n    \t// If this is a CONNECT then the variable header contains the protocol name/version, flags and keepalive time\n    \t\n    \telse if (this.type == MESSAGE_TYPE.CONNECT) {\n    \t\tbyteStream.set(MqttProtoIdentifier, pos);\n    \t\tpos += MqttProtoIdentifier.length;\n    \t\tvar connectFlags = 0;\n    \t\tif (this.cleanSession) \n    \t\t\tconnectFlags = 0x02;\n    \t\tif (this.willMessage != undefined ) {\n    \t\t\tconnectFlags |= 0x04;\n    \t\t\tconnectFlags |= (this.willMessage.qos<<3);\n    \t\t\tif (this.willMessage.retained) {\n    \t\t\t\tconnectFlags |= 0x20;\n    \t\t\t}\n    \t\t}\n    \t\tif (this.userName != undefined)\n    \t\t\tconnectFlags |= 0x80;\n            if (this.password != undefined)\n    \t\t    connectFlags |= 0x40;\n    \t\tbyteStream[pos++] = connectFlags; \n    \t\tpos = writeUint16 (this.keepAliveInterval, byteStream, pos);\n    \t}\n\n    \t// Output the messageIdentifier - if there is one\n    \tif (this.messageIdentifier != undefined)\n    \t\tpos = writeUint16 (this.messageIdentifier, byteStream, pos);\n\n    \tswitch(this.type) {\n    \t    case MESSAGE_TYPE.CONNECT:\n    \t\t    pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos); \n    \t\t    if (this.willMessage != undefined) {\n    \t\t        pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);\n    \t\t        pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\n    \t\t        byteStream.set(willMessagePayloadBytes, pos);\n\t\t        \tpos += willMessagePayloadBytes.byteLength;\n    \t\t        \n    \t        }\n    \t\tif (this.userName != undefined) \n    \t\t\tpos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);\n    \t\tif (this.password != undefined) \n    \t\t\tpos = writeString(this.password, UTF8Length(this.password), byteStream, pos);\n    \t\tbreak;\n\n    \t    case MESSAGE_TYPE.PUBLISH:\t\n    \t    \t// PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\t\n    \t    \tbyteStream.set(payloadBytes, pos);\n    \t    \t\t\n    \t    \tbreak;\n\n//    \t    case MESSAGE_TYPE.PUBREC:\t\n//    \t    case MESSAGE_TYPE.PUBREL:\t\n//    \t    case MESSAGE_TYPE.PUBCOMP:\t\n//    \t    \tbreak;\n\n    \t    case MESSAGE_TYPE.SUBSCRIBE:\n    \t    \t// SUBSCRIBE has a list of topic strings and request QoS\n    \t    \tfor (var i=0; i<this.topics.length; i++) {\n    \t    \t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n    \t    \t\tbyteStream[pos++] = this.requestedQos[i];\n    \t    \t}\n    \t    \tbreak;\n\n    \t    case MESSAGE_TYPE.UNSUBSCRIBE:\t\n    \t    \t// UNSUBSCRIBE has a list of topic strings\n    \t    \tfor (var i=0; i<this.topics.length; i++)\n    \t    \t\tpos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n    \t    \tbreak;\n\n    \t    default:\n    \t    \t// Do nothing.\n    \t}\n\n    \treturn buffer;\n    }\t\n\n    function decodeMessage(input) {\n    \t//var msg = new Object();  // message to be constructed\n    \tvar first = input[0];\n    \tvar type = first >> 4;\n    \tvar messageInfo = first &= 0x0f;\n    \tvar pos = 1;\n    \t\n\n    \t// Decode the remaining length (MBI format)\n\n    \tvar digit;\n    \tvar remLength = 0;\n    \tvar multiplier = 1;\n    \tdo {\n    \t\tdigit = input[pos++];\n    \t\tremLength += ((digit & 0x7F) * multiplier);\n    \t\tmultiplier *= 128;\n    \t} while ((digit & 0x80) != 0);\n\n    \tvar wireMessage = new WireMessage(type);\n    \tswitch(type) {\n            case MESSAGE_TYPE.CONNACK:\n    \t    \twireMessage.topicNameCompressionResponse = input[pos++];\n    \t        wireMessage.returnCode = input[pos++];\n    \t\t    break;\n    \t    \n    \t    case MESSAGE_TYPE.PUBLISH:     \t    \t\n    \t    \tvar qos = (messageInfo >> 1) & 0x03;\n    \t    \t   \t\t    \n    \t    \tvar len = readUint16(input, pos);\n    \t\t    pos += 2;\n    \t\t    var topicName = parseUTF8(input, pos, len);\n    \t\t    pos += len;\n    \t\t    // If QoS 1 or 2 there will be a messageIdentifier\n                if (qos > 0) {\n    \t\t        wireMessage.messageIdentifier = readUint16(input, pos);\n    \t\t        pos += 2;\n                }\n                \n                var message = new Messaging.Message(input.subarray(pos));\n                if ((messageInfo & 0x01) == 0x01) \n    \t    \t\tmessage.retained = true;\n    \t    \tif ((messageInfo & 0x08) == 0x08)\n    \t    \t\tmessage.duplicate =  true;\n                message.qos = qos;\n                message.destinationName = topicName;\n                wireMessage.payloadMessage = message;\t\n    \t\t    break;\n    \t    \n    \t    case  MESSAGE_TYPE.PUBACK:\n    \t    case  MESSAGE_TYPE.PUBREC:\t    \n    \t    case  MESSAGE_TYPE.PUBREL:    \n    \t    case  MESSAGE_TYPE.PUBCOMP:\n    \t    case  MESSAGE_TYPE.UNSUBACK:    \t    \t\n    \t    \twireMessage.messageIdentifier = readUint16(input, pos);\n        \t\tbreak;\n    \t\t    \n    \t    case  MESSAGE_TYPE.SUBACK:\n    \t    \twireMessage.messageIdentifier = readUint16(input, pos);\n        \t\tpos += 2;\n    \t        wireMessage.grantedQos = input.subarray(pos);\t\n    \t\t    break;\n    \t\n    \t    default:\n    \t    \t;\n    \t}\n    \t    \t\n    \treturn wireMessage;\t\n    }\n\n    function writeUint16(input, buffer, offset) {\n    \tbuffer[offset++] = input >> 8;      //MSB\n    \tbuffer[offset++] = input % 256;     //LSB \n    \treturn offset;\n    }\t\n\n    function writeString(input, utf8Length, buffer, offset) {\n    \toffset = writeUint16(utf8Length, buffer, offset);\n    \tstringToUTF8(input, buffer, offset);\n    \treturn offset + utf8Length;\n    }\t\n\n    function readUint16(buffer, offset) {\n    \treturn 256*buffer[offset] + buffer[offset+1];\n    }\t\n\n    /**\n     * Encodes an MQTT Multi-Byte Integer\n     * @private \n     */\n    function encodeMBI(number) {\n    \tvar output = new Array(1);\n    \tvar numBytes = 0;\n\n    \tdo {\n    \t\tvar digit = number % 128;\n    \t\tnumber = number >> 7;\n    \t\tif (number > 0) {\n    \t\t\tdigit |= 0x80;\n    \t\t}\n    \t\toutput[numBytes++] = digit;\n    \t} while ( (number > 0) && (numBytes<4) );\n\n    \treturn output;\n    }\n\n    /**\n     * Takes a String and calculates its length in bytes when encoded in UTF8.\n     * @private\n     */\n    function UTF8Length(input) {\n    \tvar output = 0;\n    \tfor (var i = 0; i<input.length; i++) \n    \t{\n    \t\tvar charCode = input.charCodeAt(i);\n                if (charCode > 0x7FF)\n                   {\n                      // Surrogate pair means its a 4 byte character\n                      if (0xD800 <= charCode && charCode <= 0xDBFF)\n                        {\n                          i++;\n                          output++;\n                        }\n    \t\t       output +=3;\n                   }\n    \t\telse if (charCode > 0x7F)\n    \t\t\toutput +=2;\n    \t\telse\n    \t\t\toutput++;\n    \t} \n    \treturn output;\n    }\n    \n    /**\n     * Takes a String and writes it into an array as UTF8 encoded bytes.\n     * @private\n     */\n    function stringToUTF8(input, output, start) {\n    \tvar pos = start;\n    \tfor (var i = 0; i<input.length; i++) {\n    \t\tvar charCode = input.charCodeAt(i);\n    \t\t\n    \t\t// Check for a surrogate pair.\n    \t\tif (0xD800 <= charCode && charCode <= 0xDBFF) {\n    \t        lowCharCode = input.charCodeAt(++i);\n    \t        if (isNaN(lowCharCode)) {\n    \t        \tthrow new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));\n    \t        }\n    \t        charCode = ((charCode - 0xD800)<<10) + (lowCharCode - 0xDC00) + 0x10000;\n    \t    \n    \t    }\n    \t\t\n    \t\tif (charCode <= 0x7F) {\n    \t\t\toutput[pos++] = charCode;\n    \t\t} else if (charCode <= 0x7FF) {\n    \t\t\toutput[pos++] = charCode>>6  & 0x1F | 0xC0;\n    \t\t\toutput[pos++] = charCode     & 0x3F | 0x80;\n    \t\t} else if (charCode <= 0xFFFF) {    \t\t\t\t    \n    \t        output[pos++] = charCode>>12 & 0x0F | 0xE0;\n        \t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;   \n        \t\toutput[pos++] = charCode     & 0x3F | 0x80;   \n    \t\t} else {\n    \t\t\toutput[pos++] = charCode>>18 & 0x07 | 0xF0;\n        \t\toutput[pos++] = charCode>>12 & 0x3F | 0x80;\n        \t\toutput[pos++] = charCode>>6  & 0x3F | 0x80;\n        \t\toutput[pos++] = charCode     & 0x3F | 0x80;\n    \t\t};\n    \t} \n    \treturn output;\n    }\n    \n    function parseUTF8(input, offset, length) {\n    \tvar output = \"\";\n    \tvar utf16;\n    \tvar pos = offset;\n\n    \twhile (pos < offset+length)\n    \t{\n    \t\tvar byte1 = input[pos++];\n    \t\tif (byte1 < 128)\n    \t\t\tutf16 = byte1;\n    \t\telse \n    \t\t{\n    \t\t\tvar byte2 = input[pos++]-128;\n    \t\t\tif (byte2 < 0) \n    \t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16),\"\"]));\n    \t\t\tif (byte1 < 0xE0)             // 2 byte character\n    \t\t\t\tutf16 = 64*(byte1-0xC0) + byte2;\n    \t\t\telse \n    \t\t\t{ \n    \t\t\t\tvar byte3 = input[pos++]-128;\n    \t\t\t\tif (byte3 < 0) \n    \t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));\n    \t\t\t\tif (byte1 < 0xF0)        // 3 byte character\n    \t\t\t\t\tutf16 = 4096*(byte1-0xE0) + 64*byte2 + byte3;\n                                else\n                                {\n                                   var byte4 = input[pos++]-128;\n                                   if (byte4 < 0) \n    \t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n                                   if (byte1 < 0xF8)        // 4 byte character \n                                           utf16 = 262144*(byte1-0xF0) + 4096*byte2 + 64*byte3 + byte4;\n    \t\t\t\t   else                     // longer encodings are not supported  \n    \t\t\t\t\tthrow new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));\n                                }\n    \t\t\t}\n    \t\t}  \n\n                if (utf16 > 0xFFFF)   // 4 byte character - express as a surrogate pair\n                  {\n                     utf16 -= 0x10000;\n                     output += String.fromCharCode(0xD800 + (utf16 >> 10)); // lead character\n                     utf16 = 0xDC00 + (utf16 & 0x3FF);  // trail character\n                  }\n    \t\toutput += String.fromCharCode(utf16);\n    \t}\n    \treturn output;\n    }\n    \n    /** @ignore Repeat keepalive requests, monitor responses.*/\n    var Pinger = function(client, window, keepAliveInterval) { \n    \tthis._client = client;        \t\n     \tthis._window = window;\n     \tthis._keepAliveInterval = keepAliveInterval*1000;     \t\n        this.isReset = false;\n        \n        var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode(); \n        \n        var doTimeout = function (pinger) {\n\t        return function () {\n\t            return doPing.apply(pinger);\n\t        };\n\t    };\n\t    \n\t    /** @ignore */\n        var doPing = function() { \n        \tif (!this.isReset) {\n        \t\tthis._client._trace(\"Pinger.doPing\", \"Timed out\");\n        \t\tthis._client._disconnected( ERROR.PING_TIMEOUT.code , format(ERROR.PING_TIMEOUT));\n        \t} else {\n        \t    this.isReset = false;\n        \t    this._client._trace(\"Pinger.doPing\", \"send PINGREQ\");\n                this._client.socket.send(pingReq); \n        \t    this.timeout = this._window.setTimeout(doTimeout(this), this._keepAliveInterval);\n            }\n        }\n\n        this.reset = function() {\n        \tthis.isReset = true;\n        \tthis._window.clearTimeout(this.timeout);\n        \tif (this._keepAliveInterval > 0)\n        \t\tthis.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);\n        }\n\n        this.cancel = function() {\n        \tthis._window.clearTimeout(this.timeout);\n        }\n     }; \n\n\t/** @ignore Monitor request completion. */\n\tvar Timeout = function(client, window, timeoutSeconds, action, args) {\n\t\tthis._window = window;\n\t\tif (!timeoutSeconds)\n\t\t\ttimeoutSeconds = 30;\n\t\t\n\t\tvar doTimeout = function (action, client, args) {\n\t        return function () {\n\t            return action.apply(client, args);\n\t        };\n\t    };\n        this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);\n        \n\t\tthis.cancel = function() {\n\t\t\tthis._window.clearTimeout(this.timeout);\n\t\t}\n\t}; \n    \n    /*\n\t * Internal implementation of the Websockets MQTT V3.1 client.\n\t * \n\t * @name Messaging.ClientImpl @constructor \n\t * @param {String} host the DNS nameof the webSocket host. \n\t * @param {Number} port the port number for that host.\n\t * @param {String} clientId the MQ client identifier.\n\t */\n    var ClientImpl = function (host, port, clientId) {\n    \t// Check dependencies are satisfied in this browser.\n    \tif (!(\"WebSocket\" in global && global[\"WebSocket\"] !== null)) {\n            throw new Error(format(ERROR.UNSUPPORTED, [\"WebSocket\"]));\n \t    } \n        if (!(\"localStorage\" in global && global[\"localStorage\"] !== null)) {\n         \tthrow new Error(format(ERROR.UNSUPPORTED, [\"localStorage\"]));\n        }\n        if (!(\"ArrayBuffer\" in global && global[\"ArrayBuffer\"] !== null)) {\n         \tthrow new Error(format(ERROR.UNSUPPORTED, [\"ArrayBuffer\"]));\n        }\n    \t\n        this._trace(\"Messaging.Client\", host, port, clientId);\n\n        this.host = host;\n        this.port = port;\n        this.clientId = clientId;\n\n        // Local storagekeys are qualified with the following string.\n        this._localKey=host+\":\"+port+\":\"+clientId+\":\";\n\n        // Create private instance-only message queue\n        // Internal queue of messages to be sent, in sending order. \n        this._msg_queue = [];\n\n        // Messages we have sent and are expecting a response for, indexed by their respective message ids. \n        this._sentMessages = {};\n\n        // Messages we have received and acknowleged and are expecting a confirm message for\n        // indexed by their respective message ids. \n        this._receivedMessages = {};\n \n        // Internal list of callbacks to be executed when messages\n        // have been successfully sent over web socket, e.g. disconnect\n        // when it doesn't have to wait for ACK, just message is dispatched.\n        this._notify_msg_sent = {};\n\n        // Unique identifier for SEND messages, incrementing\n        // counter as messages are sent.\n        this._message_identifier = 1;\n        \n        // Used to determine the transmission sequence of stored sent messages.\n    \tthis._sequence = 0;\n    \t\n\n        // Load the local state, if any, from the saved version, only restore state relevant to this client.   \t\n        for(key in localStorage)\n        \tif (   key.indexOf(\"Sent:\"+this._localKey) == 0  \t\t    \n        \t    || key.indexOf(\"Received:\"+this._localKey) == 0)\n        \tthis.restore(key);\n    };\n\n    // Messaging Client public instance members. \n    ClientImpl.prototype.host;\n    ClientImpl.prototype.port;\n    ClientImpl.prototype.clientId;\n\n    // Messaging Client private instance members.\n    ClientImpl.prototype.socket;\n    /* true once we have received an acknowledgement to a CONNECT packet. */\n    ClientImpl.prototype.connected = false;\n    /* The largest message identifier allowed, may not be larger than 2**16 but \n     * if set smaller reduces the maximum number of outbound messages allowed.\n     */ \n    ClientImpl.prototype.maxMessageIdentifier = 65536;\n    ClientImpl.prototype.connectOptions;\n    ClientImpl.prototype.hostIndex;\n    ClientImpl.prototype.onConnectionLost;\n    ClientImpl.prototype.onMessageDelivered;\n    ClientImpl.prototype.onMessageArrived;\n    ClientImpl.prototype._msg_queue = null;\n    ClientImpl.prototype._connectTimeout;\n    /* Send keep alive messages. */\n    ClientImpl.prototype.pinger = null;\n    \n    ClientImpl.prototype._traceBuffer = null;\n    ClientImpl.prototype._MAX_TRACE_ENTRIES = 100;\n\n    ClientImpl.prototype.connect = function (connectOptions) {\n    \tvar connectOptionsMasked = this._traceMask(connectOptions, \"password\"); \n    \tthis._trace(\"Client.connect\", connectOptionsMasked, this.socket, this.connected);\n        \n    \tif (this.connected) \n        \tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n    \tif (this.socket)\n    \t\tthrow new Error(format(ERROR.INVALID_STATE, [\"already connected\"]));\n        \n    \tthis.connectOptions = connectOptions;\n    \t\n    \tif (connectOptions.hosts) {\n    \t    this.hostIndex = 0;\n    \t    this._doConnect(connectOptions.hosts[0], connectOptions.ports[0]);  \n    \t} else {\n            this._doConnect(this.host, this.port);  \t\t\n    \t}\n        \n    };\n\n    ClientImpl.prototype.subscribe = function (filter, subscribeOptions) {\n    \tthis._trace(\"Client.subscribe\", filter, subscribeOptions);\n              \n    \tif (!this.connected)\n    \t    throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    \t\n        var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\n        wireMessage.topics=[filter];\n        if (subscribeOptions.qos != undefined)\n        \twireMessage.requestedQos = [subscribeOptions.qos];\n        else \n        \twireMessage.requestedQos = [0];\n        \n        if (subscribeOptions.onSuccess) {\n            wireMessage.callback = function() {subscribeOptions.onSuccess({invocationContext:subscribeOptions.invocationContext});};\n        }\n        if (subscribeOptions.timeout) {\n        \twireMessage.timeOut = new Timeout(this, window, subscribeOptions.timeout, subscribeOptions.onFailure\n        \t\t\t, [{invocationContext:subscribeOptions.invocationContext, \n        \t\t\t\terrorCode:ERROR.SUBSCRIBE_TIMEOUT.code, \n        \t\t\t\terrorMessage:format(ERROR.SUBSCRIBE_TIMEOUT)}]);\n        }\n        \n        // All subscriptions return a SUBACK. \n        this._requires_ack(wireMessage);\n        this._schedule_message(wireMessage);\n    };\n\n    /** @ignore */\n    ClientImpl.prototype.unsubscribe = function(filter, unsubscribeOptions) {  \n    \tthis._trace(\"Client.unsubscribe\", filter, unsubscribeOptions);\n        \n    \tif (!this.connected)\n    \t   throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n    \t\n    \tvar wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\n        wireMessage.topics = [filter];\n        \n        if (unsubscribeOptions.onSuccess) {\n        \twireMessage.callback = function() {unsubscribeOptions.onSuccess({invocationContext:unsubscribeOptions.invocationContext});};\n        }\n        if (unsubscribeOptions.timeout) {\n        \twireMessage.timeOut = new Timeout(this, window, unsubscribeOptions.timeout, unsubscribeOptions.onFailure\n        \t\t\t, [{invocationContext:unsubscribeOptions.invocationContext,\n        \t\t\t\terrorCode:ERROR.UNSUBSCRIBE_TIMEOUT.code,\n        \t\t\t\terrorMessage:format(ERROR.UNSUBSCRIBE_TIMEOUT)}]);\n        }\n     \n        // All unsubscribes return a SUBACK.         \n        this._requires_ack(wireMessage);\n        this._schedule_message(wireMessage);\n    };\n     \n    ClientImpl.prototype.send = function (message) {\n        this._trace(\"Client.send\", message);\n\n        if (!this.connected)\n           throw new Error(format(ERROR.INVALID_STATE, [\"not connected\"]));\n        \n        wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);\n        wireMessage.payloadMessage = message;\n        \n        if (message.qos > 0)\n            this._requires_ack(wireMessage);\n        else if (this.onMessageDelivered)\n        \tthis._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);\n        this._schedule_message(wireMessage);\n    };\n    \n    ClientImpl.prototype.disconnect = function () {\n        this._trace(\"Client.disconnect\");\n\n        if (!this.socket)\n    \t\tthrow new Error(format(ERROR.INVALID_STATE, [\"not connecting or connected\"]));\n        \n        wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);\n\n        // Run the disconnected call back as soon as the message has been sent,\n        // in case of a failure later on in the disconnect processing.\n        // as a consequence, the _disconected call back may be run several times.\n        this._notify_msg_sent[wireMessage] = scope(this._disconnected, this);\n\n        this._schedule_message(wireMessage);\n    };\n    \n   ClientImpl.prototype.getTraceLog = function () {\n        if ( this._traceBuffer !== null ) {\n            this._trace(\"Client.getTraceLog\", new Date());\n            this._trace(\"Client.getTraceLog in flight messages\", this._sentMessages.length);\n            for (key in this._sentMessages)\n                this._trace(\"_sentMessages \",key, this._sentMessages[key]);\n            for (key in this._receivedMessages)\n                this._trace(\"_receivedMessages \",key, this._receivedMessages[key]);\n\n            return this._traceBuffer;\n        }\n    };\n\n    ClientImpl.prototype.startTrace = function () {\n        if ( this._traceBuffer === null ) {\n            this._traceBuffer = [];\n        }\n        this._trace(\"Client.startTrace\", new Date(), version);\n    };\n\n    ClientImpl.prototype.stopTrace = function () {\n        delete this._traceBuffer;\n    };\n\n    ClientImpl.prototype._doConnect = function (host, port) { \t        \n        // When the socket is open, this client will send the CONNECT WireMessage using the saved parameters. \n        if (this.connectOptions.useSSL)\n          wsurl = [\"wss://\", host, \":\", port, \"/mqtt\"].join(\"\");\n        else\n          wsurl = [\"ws://\", host, \":\", port, \"/mqtt\"].join(\"\");\n        this.connected = false;\n        this.socket = new WebSocket(wsurl, 'mqttv3.1');\n        this.socket.binaryType = 'arraybuffer';\n        this.socket.onopen = scope(this._on_socket_open, this);\n        this.socket.onmessage = scope(this._on_socket_message, this);\n        this.socket.onerror = scope(this._on_socket_error, this);\n        this.socket.onclose = scope(this._on_socket_close, this);\n        \n        this.pinger = new Pinger(this, window, this.connectOptions.keepAliveInterval);\n        \n        this._connectTimeout = new Timeout(this, window, this.connectOptions.timeout, this._disconnected,  [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);\n    };\n\n    \n    // Schedule a new message to be sent over the WebSockets\n    // connection. CONNECT messages cause WebSocket connection\n    // to be started. All other messages are queued internally\n    // until this has happened. When WS connection starts, process\n    // all outstanding messages. \n    ClientImpl.prototype._schedule_message = function (message) {\n        this._msg_queue.push(message);\n        // Process outstanding messages in the queue if we have an  open socket, and have received CONNACK. \n        if (this.connected) {\n            this._process_queue();\n        }\n    };\n\n    ClientImpl.prototype.store = function(prefix, wireMessage) {\n    \tstoredMessage = {type:wireMessage.type, messageIdentifier:wireMessage.messageIdentifier, version:1};\n    \t\n    \tswitch(wireMessage.type) {\n\t      case MESSAGE_TYPE.PUBLISH:\n\t    \t  if(wireMessage.pubRecReceived)\n\t    \t\t  storedMessage.pubRecReceived = true;\n\t    \t  \n\t    \t  // Convert the payload to a hex string.\n\t    \t  storedMessage.payloadMessage = {};\n\t    \t  var hex = \"\";\n\t          var messageBytes = wireMessage.payloadMessage.payloadBytes;\n\t          for (var i=0; i<messageBytes.length; i++) {\n\t            if (messageBytes[i] <= 0xF)\n\t              hex = hex+\"0\"+messageBytes[i].toString(16);\n\t            else \n\t              hex = hex+messageBytes[i].toString(16);\n\t          }\n\t    \t  storedMessage.payloadMessage.payloadHex = hex;\n\t    \t  \n\t    \t  storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;\n\t    \t  storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;\n\t    \t  if (wireMessage.payloadMessage.duplicate) \n\t    \t\t  storedMessage.payloadMessage.duplicate = true;\n\t    \t  if (wireMessage.payloadMessage.retained) \n\t    \t\t  storedMessage.payloadMessage.retained = true;\t   \n\t    \t  \n\t    \t  // Add a sequence number to sent messages.\n\t    \t  if ( prefix.indexOf(\"Sent:\") == 0 ) {\n\t    \t\t  if ( wireMessage.sequence === undefined )\n\t    \t\t      wireMessage.sequence = ++this._sequence;\n\t    \t\t  storedMessage.sequence = wireMessage.sequence;\n\t    \t  }\n\t          break;    \n\t          \n\t        default:\n\t        \tthrow Error(format(ERROR.INVALID_STORED_DATA, [key, storedMessage]));\n  \t    }\n    \tlocalStorage.setItem(prefix+this._localKey+wireMessage.messageIdentifier, JSON.stringify(storedMessage));\n    };\n    \n    ClientImpl.prototype.restore = function(key) {    \t\n    \tvar value = localStorage.getItem(key);\n    \tvar storedMessage = JSON.parse(value);\n    \t\n    \tvar wireMessage = new WireMessage(storedMessage.type, storedMessage);\n    \t\n    \tswitch(storedMessage.type) {\n\t      case MESSAGE_TYPE.PUBLISH:\n\t    \t  // Replace the payload message with a Message object.\n\t    \t  var hex = storedMessage.payloadMessage.payloadHex;\n\t    \t  var buffer = new ArrayBuffer((hex.length)/2);\n              var byteStream = new Uint8Array(buffer); \n              var i = 0;\n              while (hex.length >= 2) { \n            \t  var x = parseInt(hex.substring(0, 2), 16);\n\t              hex = hex.substring(2, hex.length);\n\t              byteStream[i++] = x;\n\t          }\n              var payloadMessage = new Messaging.Message(byteStream);\n\t      \t  \n\t    \t  payloadMessage.qos = storedMessage.payloadMessage.qos;\n\t    \t  payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n              if (storedMessage.payloadMessage.duplicate) \n\t    \t\t  payloadMessage.duplicate = true;\n\t    \t  if (storedMessage.payloadMessage.retained) \n\t    \t\t  payloadMessage.retained = true;\t \n\t    \t  wireMessage.payloadMessage = payloadMessage;\n              \n\t          break;    \n\t          \n\t        default:\n\t          throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\n\t    }\n    \t    \t\t    \t\n    \tif (key.indexOf(\"Sent:\"+this._localKey) == 0) {      \n    \t\tthis._sentMessages[wireMessage.messageIdentifier] = wireMessage;    \t\t    \n    \t} else if (key.indexOf(\"Received:\"+this._localKey) == 0) {\n    \t\tthis._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n    \t}\n    };\n    \n    ClientImpl.prototype._process_queue = function () {\n        var message = null;\n        // Process messages in order they were added\n        var fifo = this._msg_queue.reverse();\n\n        // Send all queued messages down socket connection\n        while ((message = fifo.pop())) {\n            this._socket_send(message);\n            // Notify listeners that message was successfully sent\n            if (this._notify_msg_sent[message]) {\n                this._notify_msg_sent[message]();\n                delete this._notify_msg_sent[message];\n            }\n        }\n    };\n\n    /**\n     * @ignore\n     * Expect an ACK response for this message. Add message to the set of in progress\n     * messages and set an unused identifier in this message.\n     */\n    ClientImpl.prototype._requires_ack = function (wireMessage) {\n    \tvar messageCount = Object.keys(this._sentMessages).length;\n        if (messageCount > this.maxMessageIdentifier)\n            throw Error (\"Too many messages:\"+messageCount);\n\n        while(this._sentMessages[this._message_identifier] !== undefined) {\n            this._message_identifier++;\n        }\n        wireMessage.messageIdentifier = this._message_identifier;\n        this._sentMessages[wireMessage.messageIdentifier] = wireMessage;\n        if (wireMessage.type === MESSAGE_TYPE.PUBLISH) {\n        \tthis.store(\"Sent:\", wireMessage);\n        }\n        if (this._message_identifier === this.maxMessagIdentifier) {\n            this._message_identifier = 1;\n        }\n    };\n\n    /** \n     * @ignore\n     * Called when the underlying websocket has been opened.\n     */\n    ClientImpl.prototype._on_socket_open = function () {        \n        // Create the CONNECT message object.\n        var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions); \n        wireMessage.clientId = this.clientId;\n        this._socket_send(wireMessage);\n    };\n\n    /** \n     * @ignore\n     * Called when the underlying websocket has received a complete packet.\n     */\n    ClientImpl.prototype._on_socket_message = function (event) {\n        this._trace(\"Client._on_socket_message\", event.data);\n        \n        // Reset the ping timer.\n        this.pinger.reset();\n        var byteArray = new Uint8Array(event.data);\n        try {\n            var wireMessage = decodeMessage(byteArray);\n        } catch (error) {\n        \tthis._disconnected(ERROR.INTERNAL_ERROR.code , format(ERROR.INTERNAL_ERROR, [error.message]));\n        \treturn;\n        }\n        this._trace(\"Client._on_socket_message\", wireMessage);\n\n        switch(wireMessage.type) {\n            case MESSAGE_TYPE.CONNACK:\n            \tthis._connectTimeout.cancel();\n            \t\n            \t// If we have started using clean session then clear up the local state.\n            \tif (this.connectOptions.cleanSession) {\n    \t\t    \tfor (key in this._sentMessages) {\t    \t\t\n    \t\t    \t    var sentMessage = this._sentMessages[key];\n    \t\t\t\t\tlocalStorage.removeItem(\"Sent:\"+this._localKey+sentMessage.messageIdentifier);\n    \t\t    \t}\n    \t\t\t\tthis._sentMessages = {};\n\n    \t\t\t\tfor (key in this._receivedMessages) {\n    \t\t\t\t\tvar receivedMessage = this._receivedMessages[key];\n    \t\t\t\t\tlocalStorage.removeItem(\"Received:\"+this._localKey+receivedMessage.messageIdentifier);\n    \t\t\t\t}\n    \t\t\t\tthis._receivedMessages = {};\n            \t}\n            \t// Client connected and ready for business.\n            \tif (wireMessage.returnCode === 0) {\n        \t        this.connected = true;\n                } else {\n                    this._disconnected(ERROR.CONNACK_RETURNCODE.code , format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\n                    break;\n                }\n            \t\n        \t    // Resend messages.\n            \tvar sequencedMessages = new Array();\n            \tfor (var msgId in this._sentMessages) {\n            \t    if (this._sentMessages.hasOwnProperty(msgId))\n            \t        sequencedMessages.push(this._sentMessages[msgId]);\n            \t}\n          \n        \t    // Sort sentMessages into the original sent order.\n            \tvar sequencedMessages = sequencedMessages.sort(function(a,b) {return a.sequence - b.sequence;} );\n        \t    for (var i=0, len=sequencedMessages.length; i<len; i++) {\n        \t    \tvar sentMessage = sequencedMessages[i];\n        \t    \tif (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {\n        \t    \t    var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:sentMessage.messageIdentifier});\n        \t            this._schedule_message(pubRelMessage);\n        \t    \t} else {\n        \t    \t\tthis._schedule_message(sentMessage);\n        \t    \t};\n        \t    }\n\n        \t    // Execute the connectOptions.onSuccess callback if there is one.\n        \t    if (this.connectOptions.onSuccess) {\n        \t        this.connectOptions.onSuccess({invocationContext:this.connectOptions.invocationContext});\n        \t    }\n\n        \t    // Process all queued messages now that the connection is established. \n        \t    this._process_queue();\n        \t    break;\n        \n            case MESSAGE_TYPE.PUBLISH:\n                this._receivePublish(wireMessage);\n                break;\n\n            case MESSAGE_TYPE.PUBACK:\n            \tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n                 // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\n            \tif (sentMessage) {\n                    delete this._sentMessages[wireMessage.messageIdentifier];\n                    localStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\n                    if (this.onMessageDelivered)\n                    \tthis.onMessageDelivered(sentMessage.payloadMessage);\n                }\n            \tbreak;\n            \n            case MESSAGE_TYPE.PUBREC:\n                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n                // If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\n                if (sentMessage) {\n                \tsentMessage.pubRecReceived = true;\n                    var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {messageIdentifier:wireMessage.messageIdentifier});\n                    this.store(\"Sent:\", sentMessage);\n                    this._schedule_message(pubRelMessage);\n                }\n                break;\n            \t            \t\n            case MESSAGE_TYPE.PUBREL:\n                var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];\n                localStorage.removeItem(\"Received:\"+this._localKey+wireMessage.messageIdentifier);\n                // If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\n                if (receivedMessage) {\n                    this._receiveMessage(receivedMessage);\n                    delete this._receivedMessages[wireMessage.messageIdentifier];\n                }\n                // Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\n                pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {messageIdentifier:wireMessage.messageIdentifier});\n                this._schedule_message(pubCompMessage);                    \n                    \n                \n                break;\n\n            case MESSAGE_TYPE.PUBCOMP: \n            \tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n            \tdelete this._sentMessages[wireMessage.messageIdentifier];\n                localStorage.removeItem(\"Sent:\"+this._localKey+wireMessage.messageIdentifier);\n                if (this.onMessageDelivered)\n                \tthis.onMessageDelivered(sentMessage.payloadMessage);\n                break;\n                \n            case MESSAGE_TYPE.SUBACK:\n                var sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n                if (sentMessage) {\n                \tif(sentMessage.timeOut)\n                \t    sentMessage.timeOut.cancel();\n                    if (sentMessage.callback) {\n                        sentMessage.callback();\n                    }\n                    delete this._sentMessages[wireMessage.messageIdentifier];\n                }\n                break;\n        \t    \n            case MESSAGE_TYPE.UNSUBACK:\n            \tvar sentMessage = this._sentMessages[wireMessage.messageIdentifier];\n                if (sentMessage) { \n                \tif (sentMessage.timeOut)\n                        sentMessage.timeOut.cancel();\n                    if (sentMessage.callback) {\n                        sentMessage.callback();\n                    }\n                    delete this._sentMessages[wireMessage.messageIdentifier];\n                }\n\n                break;\n                \n            case MESSAGE_TYPE.PINGRESP:\n            \tbreak;\n            \t\n            case MESSAGE_TYPE.DISCONNECT:\n            \t// Clients do not expect to receive disconnect packets.\n            \tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n            \tbreak;\n\n            default:\n            \tthis._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code , format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n        }; \n    };\n    \n    /** @ignore */\n    ClientImpl.prototype._on_socket_error = function (error) {\n    \tthis._disconnected(ERROR.SOCKET_ERROR.code , format(ERROR.SOCKET_ERROR, [error.data]));\n    };\n\n    /** @ignore */\n    ClientImpl.prototype._on_socket_close = function () {\n        this._disconnected(ERROR.SOCKET_CLOSE.code , format(ERROR.SOCKET_CLOSE));\n    };\n\n    /** @ignore */\n    ClientImpl.prototype._socket_send = function (wireMessage) {\n    \tif (wireMessage.type == 1) {\n    \t\tvar wireMessageMasked = this._traceMask(wireMessage, \"password\"); \n    \t\tthis._trace(\"Client._socket_send\", wireMessageMasked);\n    \t}\n    \telse this._trace(\"Client._socket_send\", wireMessage);\n        \n        this.socket.send(wireMessage.encode());\n        this.pinger.reset();\n    };\n    \n    /** @ignore */\n    ClientImpl.prototype._receivePublish = function (wireMessage) {\n        switch(wireMessage.payloadMessage.qos) {\n            case \"undefined\":\n            case 0:\n                this._receiveMessage(wireMessage);\n                break;\n\n            case 1:\n                var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {messageIdentifier:wireMessage.messageIdentifier});\n                this._schedule_message(pubAckMessage);\n                this._receiveMessage(wireMessage);\n                break;\n\n            case 2:\n                this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;\n                this.store(\"Received:\", wireMessage);\n                var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {messageIdentifier:wireMessage.messageIdentifier});\n                this._schedule_message(pubRecMessage);\n\n                break;\n\n            default:\n                throw Error(\"Invaild qos=\"+wireMmessage.payloadMessage.qos);\n        };\n    };\n\n    /** @ignore */\n    ClientImpl.prototype._receiveMessage = function (wireMessage) {\n        if (this.onMessageArrived) {\n            this.onMessageArrived(wireMessage.payloadMessage);\n        }\n    };\n\n    /**\n     * @ignore\n     * Client has disconnected either at its own request or because the server\n     * or network disconnected it. Remove all non-durable state.\n     * @param {errorCode} [number] the error number.\n     * @param {errorText} [string] the error text.\n     */\n    ClientImpl.prototype._disconnected = function (errorCode, errorText) {\n    \tthis.pinger.cancel();\n    \tif (this._connectTimeout)\n    \t    this._connectTimeout.cancel();\n    \t// Clear message buffers.\n        this._msg_queue = [];\n        this._notify_msg_sent = {};\n       \n        if (this.socket) {\n            // Cancel all socket callbacks so that they cannot be driven again by this socket.\n            this.socket.onopen = null;\n            this.socket.onmessage = null;\n            this.socket.onerror = null;\n            this.socket.onclose = null;\n            this.socket.close();\n            delete this.socket;           \n        }\n        \n        if (this.connectOptions.hosts && this.hostIndex < this.connectOptions.hosts.length-1) {\n        \t// Try the next host.\n        \tthis.hostIndex++;\n        \tthis._doConnect(this.connectOptions.hosts[this.hostIndex], this.connectOptions.ports[this.hostIndex]);\n        \n        } else {\n        \n            if (errorCode === undefined) {\n        \t    errorCode = ERROR.OK.code;\n        \t    errroText = format(ERROR.OK);\n            }\n        \t\n            // Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\n            if (this.connected) {\n                this.connected = false;\n                // Execute the connectionLostCallback if there is one, and we were connected.       \n                if (this.onConnectionLost)\n            \t    this.onConnectionLost({errorCode:errorCode, errorMessage:errorText});      \t\n            } else {\n        \t    // Otherwise we never had a connection, so indicate that the connect has failed.\n                if(this.connectOptions.onFailure)\n            \t    this.connectOptions.onFailure({invocationContext:this.connectOptions.invocationContext, errorCode:errorCode, errorMessage:errorText});\n            }\n        }\n    };\n\n    /** @ignore */\n    ClientImpl.prototype._trace = function () {\n        if ( this._traceBuffer !== null ) {  \n            for (var i = 0, max = arguments.length; i < max; i++) {\n                if ( this._traceBuffer.length == this._MAX_TRACE_ENTRIES ) {    \n                    this._traceBuffer.shift();              \n                }\n                if (i === 0) this._traceBuffer.push(arguments[i]);\n                else if (typeof arguments[i] === \"undefined\" ) this._traceBuffer.push(arguments[i]);\n                else this._traceBuffer.push(\"  \"+JSON.stringify(arguments[i]));\n           };\n        };\n    };\n    \n    /** @ignore */\n    ClientImpl.prototype._traceMask = function (traceObject, masked) {\n        var traceObjectMasked = {};\n\t    for (var attr in traceObject) {\n\t        if (traceObject.hasOwnProperty(attr)) {\n\t        \tif (attr == masked) \n\t        \t\ttraceObjectMasked[attr] = \"******\";\n\t        \telse\n\t        \t\ttraceObjectMasked[attr] = traceObject[attr];\n\t        } \n\t    }\n\t    return traceObjectMasked;\n    };\n\n    // ------------------------------------------------------------------------\n    // Public Programming interface.\n    // ------------------------------------------------------------------------\n    \n    /** \n     * The JavaScript application communicates to the server using a Messaging.Client object. \n     * <p>\n     * Other programming languages,\n     * <a href=\"/clients/java/doc/javadoc/com/ibm/micro/client/mqttv3/MqttClient.html\"><big>Java</big></a>,\n     * <a href=\"/clients/c/doc/html/index.html\"><big>C</big></a>.\n     * <p>\n     * Most applications will create just one Client object and then call its connect() method,\n     * however applications can create more than one Client object if they wish. \n     * In this case the combination of host, port and clientId attributes must be different for each Client object.\n     * <p>\n     * The send, subscribe and unsubscribe methods are implemented as asynchronous JavaScript methods \n     * (even though the underlying protocol exchange might be synchronous in nature). \n     * This means they signal their completion by calling back to the application, \n     * via Success or Failure callback functions provided by the application on the method in question. \n     * Such callbacks are called at most once per method invocation and do not persist beyond the lifetime \n     * of the script that made the invocation.\n     * <p>\n     * In contrast there are some callback functions <i> most notably onMessageArrived</i> \n     * that are defined on the Messaging.Client object.  \n     * These may get called multiple times, and aren't directly related to specific method invocations made by the client. \n     *\n     * @name Messaging.Client    \n     * \n     * @constructor\n     * Creates a Messaging.Client object that can be used to communicate with a Messaging server.\n     *  \n     * @param {string} host the address of the messaging server, as a DNS name or dotted decimal IP address.\n     * @param {number} port the port number in the host to connect to.\n     * @param {string} clientId the Messaging client identifier, between 1 and 23 characters in length.\n     * \n     * @property {string} host <i>read only</i> the server's DNS hostname or dotted decimal IP address.\n     * @property {number} port <i>read only</i> the server's port.\n     * @property {string} clientId <i>read only</i> used when connecting to the server.\n     * @property {function} onConnectionLost called when a connection has been lost, \n     * after a connect() method has succeeded.\n     * Establish the call back used when a connection has been lost. The connection may be\n     * lost because the client initiates a disconnect or because the server or network \n     * cause the client to be disconnected. The disconnect call back may be called without \n     * the connectionComplete call back being invoked if, for example the client fails to \n     * connect.\n     * A single response object parameter is passed to the onConnectionLost callback containing the following fields:\n     * <ol>   \n     * <li>errorCode\n     * <li>errorMessage       \n     * </ol>\n     * @property {function} onMessageDelivered called when a message has been delivered. \n     * All processing that this Client will ever do has been completed. So, for example,\n     * in the case of a Qos=2 message sent by this client, the PubComp flow has been received from the server\n     * and the message has been removed from persistent storage before this callback is invoked. \n     * Parameters passed to the onMessageDelivered callback are:\n     * <ol>   \n     * <li>Messaging.Message that was delivered.\n     * </ol>    \n     * @property {function} onMessageArrived called when a message has arrived in this Messaging.client. \n     * Parameters passed to the onMessageArrived callback are:\n     * <ol>   \n     * <li>Messaging.Message that has arrived.\n     * </ol>    \n     */\n    var Client = function (host, port, clientId) {\n    \tif (typeof host !== \"string\")\n        \tthrow new Error(format(ERROR.INVALID_TYPE, [typeof host, \"host\"]));\n    \tif (typeof port !== \"number\" || port < 0)\n        \tthrow new Error(format(ERROR.INVALID_TYPE, [typeof port, \"port\"]));\n    \t\n    \tvar clientIdLength = 0;\n    \tfor (var i = 0; i<clientId.length; i++) {\n    \t\tvar charCode = clientId.charCodeAt(i);                   \n    \t\tif (0xD800 <= charCode && charCode <= 0xDBFF)  {    \t\t\t\n                 i++; // Surrogate pair.\n            }   \t\t   \n    \t\tclientIdLength++;\n    \t}     \t   \t\n        if (typeof clientId !== \"string\")\n        \tthrow new Error(format(ERROR.INVALID_ARGUMENT, [clientId, \"clientId\"])); \n    \t\n        var client = new ClientImpl(host, port, clientId);\n        this._getHost =  function() { return client.host; };\n    \tthis._setHost = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n         \t\n        this._getPort = function() { return client.port; };\n    \tthis._setPort = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n    \t\n    \tthis._getClientId = function() { return client.clientId; };\n    \tthis._setClientId = function() { throw new Error(format(ERROR.UNSUPPORTED_OPERATION)); };\n        \n        this._getOnConnectionLost = function() { return client.onConnectionLost; };\n        this._setOnConnectionLost = function(newOnConnectionLost) { \n            if (typeof newOnConnectionLost === \"function\")\n            \tclient.onConnectionLost = newOnConnectionLost;\n            else \n    \t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, \"onConnectionLost\"]));\n        };\n\n        this._getOnMessageDelivered = function() { return client.onMessageDelivered; };\n    \tthis._setOnMessageDelivered = function(newOnMessageDelivered) { \n    \t\tif (typeof newOnMessageDelivered === \"function\")\n    \t\t\tclient.onMessageDelivered = newOnMessageDelivered;\n    \t\telse \n    \t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, \"onMessageDelivered\"]));\n    \t};\n       \n        this._getOnMessageArrived = function() { return client.onMessageArrived; };\n    \tthis._setOnMessageArrived = function(newOnMessageArrived) { \n    \t\tif (typeof newOnMessageArrived === \"function\")\n    \t\t\tclient.onMessageArrived = newOnMessageArrived;\n    \t\telse \n    \t\t\tthrow new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, \"onMessageArrived\"]));\n    \t};\n        \n        /** \n         * Connect this Messaging client to its server. \n         * \n         * @name Messaging.Client#connect\n         * @function\n         * @param {Object} [connectOptions] attributes used with the connection. \n         * <p>\n         * Properties of the connect options are: \n         * @config {number} [timeout] If the connect has not succeeded within this number of seconds, it is deemed to have failed.\n         *                            The default is 30 seconds.\n         * @config {string} [userName] Authentication username for this connection.\n         * @config {string} [password] Authentication password for this connection.\n         * @config {Messaging.Message} [willMessage] sent by the server when the client disconnects abnormally.\n         * @config {Number} [keepAliveInterval] the server disconnects this client if there is no activity for this\n         *                number of seconds. The default value of 60 seconds is assumed if not set.\n         * @config {boolean} [cleanSession] if true(default) the client and server persistent state is deleted on successful connect.\n         * @config {boolean} [useSSL] if present and true, use an SSL Websocket connection.\n         * @config {object} [invocationContext] passed to the onSuccess callback or onFailure callback.\n         * @config {function} [onSuccess] called when the connect acknowledgement has been received from the server.\n         * A single response object parameter is passed to the onSuccess callback containing the following fields:\n         * <ol>\n         * <li>invocationContext as passed in to the onSuccess method in the connectOptions.       \n         * </ol>\n         * @config {function} [onFailure] called when the connect request has failed or timed out.\n         * A single response object parameter is passed to the onFailure callback containing the following fields:\n         * <ol>\n         * <li>invocationContext as passed in to the onFailure method in the connectOptions.       \n         * <li>errorCode a number indicating the nature of the error.\n         * <li>errorMessage text describing the error.      \n         * </ol>\n         * @config {Array} [hosts] If present this set of hostnames is tried in order in place \n         * of the host and port paramater on the construtor. The hosts and the matching ports are tried one at at time in order until\n         * one of then succeeds.\n         * @config {Array} [ports] If present this set of ports matching the hosts.\n         * @throws {InvalidState} if the client is not in disconnected state. The client must have received connectionLost\n         * or disconnected before calling connect for a second or subsequent time.\n         */\n        this.connect = function (connectOptions) {\n        \tconnectOptions = connectOptions || {} ;\n        \tvalidate(connectOptions,  {timeout:\"number\",\n        \t\t\t                   userName:\"string\", \n        \t\t                       password:\"string\", \n        \t\t                       willMessage:\"object\", \n        \t\t                       keepAliveInterval:\"number\", \n        \t\t                       cleanSession:\"boolean\", \n        \t\t                       useSSL:\"boolean\",\n        \t\t                       invocationContext:\"object\", \n      \t\t                           onSuccess:\"function\", \n      \t\t                           onFailure:\"function\",\n      \t\t                           hosts:\"object\",\n      \t\t                           ports:\"object\"});\n        \t\n        \t// If no keep alive interval is set, assume 60 seconds.\n            if (connectOptions.keepAliveInterval === undefined)\n            \tconnectOptions.keepAliveInterval = 60;\n\n        \tif (connectOptions.willMessage) {\n                if (!(connectOptions.willMessage instanceof Message))\n            \t    throw new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, \"connectOptions.willMessage\"]));\n                // The will message must have a payload that can be represented as a string.\n                // Cause the willMessage to throw an exception if this is not the case.\n            \tconnectOptions.willMessage.stringPayload;\n            \t\n            \tif (typeof connectOptions.willMessage.destinationName === \"undefined\")\n                \tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, \"connectOptions.willMessage.destinationName\"]));\n        \t}\n        \tif (typeof connectOptions.cleanSession === \"undefined\")\n        \t\tconnectOptions.cleanSession = true;\n        \tif (connectOptions.hosts) {\n        \t\tif (!connectOptions.ports)\n        \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n        \t\tif (!(connectOptions.hosts instanceof Array) )\n        \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n        \t\tif (!(connectOptions.ports instanceof Array) )\n        \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n        \t\tif (connectOptions.hosts.length <1 )\n        \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, \"connectOptions.hosts\"]));\n        \t\tif (connectOptions.hosts.length != connectOptions.ports.length)\n        \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, \"connectOptions.ports\"]));\n        \t\tfor (var i = 0; i<connectOptions.hosts.length; i++) {\n        \t\t\tif (typeof connectOptions.hosts[i] !== \"string\")\n        \t        \tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], \"connectionstions.hosts[\"+i+\"]\"]));\n        \t\t\tif (typeof connectOptions.ports[i] !== \"number\" || connectOptions.ports[i] < 0)\n        \t        \tthrow new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], \"connectionstions.ports[\"+i+\"]\"]));\n        \t    }\n        \t}\n\n        \tclient.connect(connectOptions);\n        };\n     \n        /** \n         * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\n         * \n         * @name Messaging.Client#subscribe\n         * @function\n         * @param {string} filter describing the destinations to receive messages from.\n         * <br>\n         * @param {object} [subscribeOptions] used to control the subscription, as follows:\n         * <p>\n         * @config {number} [qos] the maiximum qos of any publications sent as a result of making this subscription.\n         * @config {object} [invocationContext] passed to the onSuccess callback or onFailure callback.\n         * @config {function} [onSuccess] called when the subscribe acknowledgement has been received from the server.\n         * A single response object parameter is passed to the onSuccess callback containing the following fields:\n         * <ol>\n         * <li>invocationContext if set in the subscribeOptions.       \n         * </ol>\n         * @config {function} [onFailure] called when the subscribe request has failed or timed out.\n         * A single response object parameter is passed to the onFailure callback containing the following fields:\n         * <ol>\n         * <li>invocationContext if set in the subscribeOptions.       \n         * <li>errorCode a number indicating the nature of the error.\n         * <li>errorMessage text describing the error.      \n         * </ol>\n         * @config {number} [timeout] which if present determines the number of seconds after which the onFailure calback is called\n         * the presence of a timeout does not prevent the onSuccess callback from being called when the MQTT Suback is eventually received.         \n    \t * @throws {InvalidState} if the client is not in connected state.\n         */\n        this.subscribe = function (filter, subscribeOptions) {\n        \tif (typeof filter !== \"string\")\n        \t\tthrow new Error(\"Invalid argument:\"+filter);\n        \tsubscribeOptions = subscribeOptions || {} ;\n        \tvalidate(subscribeOptions,  {qos:\"number\", \n        \t\t                         invocationContext:\"object\", \n        \t\t                         onSuccess:\"function\", \n        \t\t                         onFailure:\"function\",\n        \t\t                         timeout:\"number\"\n        \t\t                        });\n        \tif (subscribeOptions.timeout && !subscribeOptions.onFailure)\n        \t\tthrow new Error(\"subscribeOptions.timeout specified with no onFailure callback.\");\n        \tif (typeof subscribeOptions.qos !== \"undefined\" \n        \t\t&& !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2 ))\n    \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, \"subscribeOptions.qos\"]));\n            client.subscribe(filter, subscribeOptions);\n        };\n\n        /**\n         * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\n         * \n         * @name Messaging.Client#unsubscribe\n         * @function\n         * @param {string} filter describing the destinations to receive messages from.\n         * @param {object} [unsubscribeOptions] used to control the subscription, as follows:\n         * <p>\n         * @config {object} [invocationContext] passed to the onSuccess callback or onFailure callback.\n         * @config {function} [onSuccess] called when the unsubscribe acknowledgement has been receive dfrom the server.\n         * A single response object parameter is passed to the onSuccess callback containing the following fields:\n         * <ol>\n         * <li>invocationContext if set in the unsubscribeOptions.     \n         * </ol>\n         * @config {function} [onFailure] called when the unsubscribe request has failed or timed out.\n         * A single response object parameter is passed to the onFailure callback containing the following fields:\n         * <ol>\n         * <li>invocationContext if set in the unsubscribeOptions.       \n         * <li>errorCode a number indicating the nature of the error.\n         * <li>errorMessage text describing the error.      \n         * </ol>\n         * @config {number} [timeout] which if present determines the number of seconds after which the onFailure callback is called, the\n         * presence of a timeout does not prevent the onSuccess callback from being called when the MQTT UnSuback is eventually received.\n         * @throws {InvalidState} if the client is not in connected state.\n         */\n        this.unsubscribe = function (filter, unsubscribeOptions) {\n        \tif (typeof filter !== \"string\")\n        \t\tthrow new Error(\"Invalid argument:\"+filter);\n        \tunsubscribeOptions = unsubscribeOptions || {} ;\n        \tvalidate(unsubscribeOptions,  {invocationContext:\"object\", \n        \t\t                           onSuccess:\"function\", \n        \t\t                           onFailure:\"function\",\n        \t\t                           timeout:\"number\"\n        \t\t                          });\n        \tif (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure)\n        \t\tthrow new Error(\"unsubscribeOptions.timeout specified with no onFailure callback.\");\n            client.unsubscribe(filter, unsubscribeOptions);\n        };\n\n        /**\n         * Send a message to the consumers of the destination in the Message.\n         * \n         * @name Messaging.Client#send\n         * @function \n         * @param {Messaging.Message} message to send.\n         \n         * @throws {InvalidState} if the client is not in connected state.\n         */   \n        this.send = function (message) {       \t\n            if (!(message instanceof Message))\n                throw new Error(\"Invalid argument:\"+typeof message);\n            if (typeof message.destinationName === \"undefined\")\n            \tthrow new Error(\"Invalid parameter Message.destinationName:\"+message.destinationName);\n           \n            client.send(message);   \n        };\n        \n        /** \n         * Normal disconnect of this Messaging client from its server.\n         * \n         * @name Messaging.Client#disconnect\n         * @function\n         * @throws {InvalidState} if the client is not in connected or connecting state.     \n         */\n        this.disconnect = function () {\n        \tclient.disconnect();\n        };\n        \n        /** \n         * Get the contents of the trace log.\n         * \n         * @name Messaging.Client#getTraceLog\n         * @function\n         * @return {Object[]} tracebuffer containing the time ordered trace records.\n         */\n        this.getTraceLog = function () {\n        \treturn client.getTraceLog();\n        }\n        \n        /** \n         * Start tracing.\n         * \n         * @name Messaging.Client#startTrace\n         * @function\n         */\n        this.startTrace = function () {\n        \tclient.startTrace();\n        };\n        \n        /** \n         * Stop tracing.\n         * \n         * @name Messaging.Client#stopTrace\n         * @function\n         */\n        this.stopTrace = function () {\n            client.stopTrace();\n        };\n    };\n\n    Client.prototype = {\n        get host() { return this._getHost(); },\n        set host(newHost) { this._setHost(newHost); },\n        \t\n        get port() { return this._getPort(); },\n        set port(newPort) { this._setPort(newPort); },\n        \t\n        get clientId() { return this._getClientId(); },\n        set clientId(newClientId) { this._setClientId(newClientId); },\n\n        get onConnectionLost() { return this._getOnConnectionLost(); },\n        set onConnectionLost(newOnConnectionLost) { this._setOnConnectionLost(newOnConnectionLost); },\n\n        get onMessageDelivered() { return this._getOnMessageDelivered(); },\n        set onMessageDelivered(newOnMessageDelivered) { this._setOnMessageDelivered(newOnMessageDelivered); },\n        \n        get onMessageArrived() { return this._getOnMessageArrived(); },\n        set onMessageArrived(newOnMessageArrived) { this._setOnMessageArrived(newOnMessageArrived); }\n    };\n    \n    /** \n     * An application message, sent or received.\n     * <p>\n     * Other programming languages,\n     * <a href=\"/clients/java/doc/javadoc/com/ibm/micro/client/mqttv3/MqttMessage.html\"><big>Java</big></a>,\n     * <a href=\"/clients/c/doc/html/struct_m_q_t_t_client__message.html\"><big>C</big></a>.\n     * <p>\n     * All attributes may be null, which implies the default values.\n     * \n     * @name Messaging.Message\n     * @constructor\n     * @param {String|ArrayBuffer} payload The message data to be sent.\n     * <p>\n     * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\n     * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\n     * <p>\n     * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\n     *                    (for messages about to be sent) or the name of the destination from which the message has been received.\n     *                    (for messages received by the onMessage function).\n     * <p>\n     * @property {number} qos The Quality of Service used to deliver the message.\n     * <dl>\n     *     <dt>0 Best effort (default).\n     *     <dt>1 At least once.\n     *     <dt>2 Exactly once.     \n     * </dl>\n     * <p>\n     * @property {Boolean} retained If true, the message is to be retained by the server and delivered \n   \t *                     to both current and future subscriptions.\n   \t *                     If false the server only delivers the message to current subscribers, this is the default for new Messages. \n   \t *                     A received message has the retained boolean set to true if the message was published \n   \t *                     with the retained boolean set to true\n   \t *                     and the subscrption was made after the message has been published. \n   \t * <p>\n     * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received. \n     *                     This is only set on messages received from the server.\n     *                     \n     */\n    var Message = function (newPayload) {  \n    \tvar payload;\n    \tif (   typeof newPayload === \"string\" \n    \t\t|| newPayload instanceof ArrayBuffer\n    \t\t|| newPayload instanceof Int8Array\n    \t\t|| newPayload instanceof Uint8Array\n    \t\t|| newPayload instanceof Int16Array\n    \t\t|| newPayload instanceof Uint16Array\n    \t\t|| newPayload instanceof Int32Array\n    \t\t|| newPayload instanceof Uint32Array\n    \t\t|| newPayload instanceof Float32Array\n    \t\t|| newPayload instanceof Float64Array\n    \t   ) {\n            payload = newPayload;\n        } else {\n            throw (format(ERROR.INVALID_ARGUMENT, [newPayload, \"newPayload\"]));\n        }\n\n    \tthis._getPayloadString = function () {\n    \t\tif (typeof payload === \"string\")\n       \t\t\treturn payload;\n       \t\telse\n       \t\t\treturn parseUTF8(payload, 0, payload.length); \n    \t};\n\n    \tthis._getPayloadBytes = function() {\n    \t\tif (typeof payload === \"string\") {\n    \t\t\tvar buffer = new ArrayBuffer(UTF8Length(payload));\n    \t\t\tvar byteStream = new Uint8Array(buffer); \n    \t\t\tstringToUTF8(payload, byteStream, 0);\n\n    \t\t\treturn byteStream;\n    \t\t} else {\n    \t\t\treturn payload;\n    \t\t};\n    \t};\n\n    \tvar destinationName = undefined;\n    \tthis._getDestinationName = function() { return destinationName; };\n    \tthis._setDestinationName = function(newDestinationName) { \n    \t\tif (typeof newDestinationName === \"string\")\n    \t\t    destinationName = newDestinationName;\n    \t\telse \n    \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, \"newDestinationName\"]));\n    \t};\n    \t    \t\n    \tvar qos = 0;\n    \tthis._getQos = function() { return qos; };\n    \tthis._setQos = function(newQos) { \n    \t\tif (newQos === 0 || newQos === 1 || newQos === 2 )\n    \t\t\tqos = newQos;\n    \t\telse \n    \t\t\tthrow new Error(\"Invalid argument:\"+newQos);\n    \t};\n\n    \tvar retained = false;\n    \tthis._getRetained = function() { return retained; };\n    \tthis._setRetained = function(newRetained) { \n    \t\tif (typeof newRetained === \"boolean\")\n    \t\t    retained = newRetained;\n    \t\telse \n    \t\t\tthrow new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, \"newRetained\"]));\n    \t};\n    \t\n    \tvar duplicate = false;\n    \tthis._getDuplicate = function() { return duplicate; };\n    \tthis._setDuplicate = function(newDuplicate) { duplicate = newDuplicate; };\n    };\n    \n    Message.prototype = {\n    \tget payloadString() { return this._getPayloadString(); },\n    \tget payloadBytes() { return this._getPayloadBytes(); },\n    \t\n    \tget destinationName() { return this._getDestinationName(); },\n    \tset destinationName(newDestinationName) { this._setDestinationName(newDestinationName); },\n    \t\n    \tget qos() { return this._getQos(); },\n    \tset qos(newQos) { this._setQos(newQos); },\n\n    \tget retained() { return this._getRetained(); },\n    \tset retained(newRetained) { this._setRetained(newRetained); },\n\n    \tget duplicate() { return this._getDuplicate(); },\n    \tset duplicate(newDuplicate) { this._setDuplicate(newDuplicate); }\n    };\n       \n    // Module contents.\n    return {\n        Client: Client,\n        Message: Message\n    };\n})(window);\n","output":"str","x":390,"y":140,"wires":[["bed00afc.27d2f8"]]},{"id":"bed00afc.27d2f8","type":"http response","z":"742c51ad.23eee8","name":"","statusCode":"","headers":{},"x":570,"y":160,"wires":[]},{"id":"e5a64a52.ba98","type":"http in","z":"742c51ad.23eee8","name":"","url":"/render.js","method":"get","upload":false,"swaggerDoc":"","x":197.5,"y":309.25,"wires":[["a8fec77f.43696"]]},{"id":"a8fec77f.43696","type":"template","z":"742c51ad.23eee8","name":"JavaScript","field":"payload","fieldType":"msg","format":"javascript","syntax":"plain","template":"/*\n 現在の盤面の状態を描画する処理\n */\nvar canvas = document.getElementsByTagName( 'canvas' )[ 0 ];  // キャンバス\nvar ctx = canvas.getContext( '2d' ); // コンテクスト\nvar W = 300, H = 600;  // キャンバスのサイズ\nvar BLOCK_W = W / COLS, BLOCK_H = H / ROWS;  // マスの幅を設定\n\n// x, yの部分へマスを描画する処理\nfunction drawBlock( x, y ) {\n  ctx.fillRect( BLOCK_W * x, BLOCK_H * y, BLOCK_W - 1 , BLOCK_H - 1 );\n  ctx.strokeRect( BLOCK_W * x, BLOCK_H * y, BLOCK_W - 1 , BLOCK_H - 1 );\n}\n\n// 盤面と操作ブロックを描画する\nfunction render() {\n  ctx.clearRect( 0, 0, W, H );  // 一度キャンバスを真っさらにする\n  ctx.strokeStyle = 'black';  // えんぴつの色を黒にする\n\n  // 盤面を描画する\n  for ( var x = 0; x < COLS; ++x ) {\n    for ( var y = 0; y < ROWS; ++y ) {\n      if ( board[ y ][ x ] ) {  // マスが空、つまり0ではなかったら\n        ctx.fillStyle = colors[ board[ y ][ x ] - 1 ];  // マスの種類に合わせて塗りつぶす色を設定\n        drawBlock( x, y );  // マスを描画\n      }\n    }\n  }\n\n  // 操作ブロックを描画する\n  for ( var y = 0; y < 4; ++y ) {\n    for ( var x = 0; x < 4; ++x ) {\n      if ( current[ y ][ x ] ) {\n        ctx.fillStyle = colors[ current[ y ][ x ] - 1 ];  // マスの種類に合わせて塗りつぶす色を設定\n        drawBlock( currentX + x, currentY + y );  // マスを描画\n      }\n    }\n  }\n}\n\n// 30ミリ秒ごとに状態を描画する関数を呼び出す\nsetInterval( render, 30 );\n\n","output":"str","x":376.5,"y":315.75,"wires":[["e730f63b.503c38"]]},{"id":"e730f63b.503c38","type":"http response","z":"742c51ad.23eee8","name":"","statusCode":"","headers":{},"x":530.5,"y":327.5,"wires":[]},{"id":"4d625950.508bf","type":"http in","z":"742c51ad.23eee8","name":"","url":"/tetris.html","method":"get","upload":false,"swaggerDoc":"","x":173.5,"y":485.25,"wires":[["b628dd2d.66bb6"]]},{"id":"b628dd2d.66bb6","type":"template","z":"742c51ad.23eee8","name":"HTML","field":"payload","fieldType":"msg","format":"html","syntax":"plain","template":"<!DOCTYPE html>\n<html>\n<head>\n<title>HTML5 Tetris</title>\n<style>\ncanvas {\n    display: block;\n    margin: auto;\n    border: 1px solid black;\n}\n</style>\n</head>\n<body onload=\"connect()\">\n    <canvas width='300' height='600'></canvas>\n    <script src='./tetris.js'></script>\n    <script src='./controller.js'></script>\n    <script src='./render.js'></script>\n</body>\n</html>\n","output":"str","x":330,"y":500,"wires":[["d0b5a3b0.0d05f"]]},{"id":"d0b5a3b0.0d05f","type":"http response","z":"742c51ad.23eee8","name":"","statusCode":"","headers":{},"x":470.5,"y":509.5,"wires":[]},{"id":"a49d95bb.2cf57","type":"http in","z":"742c51ad.23eee8","name":"","url":"/tetris.js","method":"get","upload":false,"swaggerDoc":"","x":181.5,"y":571.25,"wires":[["f8d03e55.3262a"]]},{"id":"7d2d5246.7cbcb4","type":"http response","z":"742c51ad.23eee8","name":"","statusCode":"","headers":{},"x":563.5,"y":633.5,"wires":[]},{"id":"f8d03e55.3262a","type":"template","z":"742c51ad.23eee8","name":"JavaScript","field":"payload","fieldType":"msg","format":"javascript","syntax":"plain","template":"var COLS = 10, ROWS = 20;  // 横10、縦20マス\nvar board = [];  // 盤面情報\nvar lose;  // 一番上までいっちゃったかどうか\nvar interval;  // ゲームを実行するタイマーを保持する変数\nvar current; // 今操作しているブロックの形\nvar currentX, currentY; // 今操作しているブロックの位置\n\n// 操作するブロックのパターン\nvar shapes = [\n    [ 1, 1, 1, 1 ],\n    [ 1, 1, 1, 0,\n      1 ],\n    [ 1, 1, 1, 0,\n      0, 0, 1 ],\n    [ 1, 1, 0, 0,\n      1, 1 ],\n    [ 1, 1, 0, 0,\n      0, 1, 1 ],\n    [ 0, 1, 1, 0,\n      1, 1 ],\n    [ 0, 1, 0, 0,\n      1, 1, 1 ]\n];\n\n// ブロックの色\nvar colors = [\n    'cyan', 'orange', 'blue', 'yellow', 'red', 'green', 'purple'\n];\n\n\n// 盤面を空にする\nfunction init() {\n  for ( var y = 0; y < ROWS; ++y ) {\n    board[ y ] = [];\n    for ( var x = 0; x < COLS; ++x ) {\n      board[ y ][ x ] = 0;\n    }\n  }\n}\n\n// shapesからランダムにブロックのパターンを出力し、盤面の一番上へセットする\nfunction newShape() {\n  var id = Math.floor( Math.random() * shapes.length );  // ランダムにインデックスを出す\n  var shape = shapes[ id ];\n  // パターンを操作ブロックへセットする\n  current = [];\n  for ( var y = 0; y < 4; ++y ) {\n    current[ y ] = [];\n    for ( var x = 0; x < 4; ++x ) {\n      var i = 4 * y + x;\n      if ( typeof shape[ i ] != 'undefined' && shape[ i ] ) {\n        current[ y ][ x ] = id + 1;\n      }\n      else {\n        current[ y ][ x ] = 0;\n      }\n    }\n  }\n  // ブロックを盤面の上のほうにセットする\n  currentX = 5;\n  currentY = 0;\n}\n\nfunction tick() {\n  // １つ下へ移動する\n  if ( valid( 0, 1 ) ) {\n    ++currentY;\n  }\n  // もし着地していたら(１つしたにブロックがあったら)\n  else {\n    freeze();  // 操作ブロックを盤面へ固定する\n    clearLines();  // ライン消去処理\n    if (lose) {\n      // もしゲームオーバなら最初から始める\n      newGame();\n      return false;\n    }\n    // 新しい操作ブロックをセットする\n    newShape();\n  }\n}\n\n// 指定された方向に、操作ブロックを動かせるかどうかチェックする\n// ゲームオーバー判定もここで行う\nfunction valid( offsetX, offsetY, newCurrent ) {\n  offsetX = offsetX || 0;\n  offsetY = offsetY || 0;\n  offsetX = currentX + offsetX;\n  offsetY = currentY + offsetY;\n  newCurrent = newCurrent || current;\n  for ( var y = 0; y < 4; ++y ) {\n    for ( var x = 0; x < 4; ++x ) {\n      if ( newCurrent[ y ][ x ] ) {\n        if ( typeof board[ y + offsetY ] == 'undefined'\n             || typeof board[ y + offsetY ][ x + offsetX ] == 'undefined'\n             || board[ y + offsetY ][ x + offsetX ]\n             || x + offsetX < 0\n             || y + offsetY >= ROWS\n             || x + offsetX >= COLS ) {\n                    if (offsetY == 1 && offsetX - currentX == 0 && offsetY - currentY == 1) {\n                        console.log('game over');\n                        lose = true; // もし操作ブロックが盤面の上にあったらゲームオーバーにする\n                    }\n               return false;\n             }\n      }\n    }\n  }\n  return true;\n}\n\n// 操作ブロックを盤面にセットする関数\nfunction freeze() {\n  for ( var y = 0; y < 4; ++y ) {\n    for ( var x = 0; x < 4; ++x ) {\n      if ( current[ y ][ x ] ) {\n        board[ y + currentY ][ x + currentX ] = current[ y ][ x ];\n      }\n    }\n  }\n}\n\n// 一行が揃っているか調べ、揃っていたらそれらを消す\nfunction clearLines() {\n  for ( var y = ROWS - 1; y >= 0; --y ) {\n    var rowFilled = true;\n    // 一行が揃っているか調べる\n    for ( var x = 0; x < COLS; ++x ) {\n      if ( board[ y ][ x ] == 0 ) {\n        rowFilled = false;\n        break;\n      }\n    }\n    // もし一行揃っていたら, サウンドを鳴らしてそれらを消す。\n    if ( rowFilled ) {\n      document.getElementById( 'clearsound' ).play();  // 消滅サウンドを鳴らす\n      // その上にあったブロックを一つずつ落としていく\n      for ( var yy = y; yy > 0; --yy ) {\n        for ( var x = 0; x < COLS; ++x ) {\n          board[ yy ][ x ] = board[ yy - 1 ][ x ];\n        }\n      }\n      ++y;  // 一行落としたのでチェック処理を一つ下へ送る\n    }\n  }\n}\n\n\n\n\nfunction newGame() {\n  clearInterval(interval);  // ゲームタイマーをクリア\n  init();  // 盤面をまっさらにする\n  newShape();  // 操作ブロックをセット\n  lose = false;  // 負けフラッグ\n  interval = setInterval( tick, 500 );  // 250ミリ秒ごとにtickという関数を呼び出す\n}\n\nnewGame();\n","output":"str","x":370,"y":600,"wires":[["7d2d5246.7cbcb4"]]},{"id":"473345d2.daa4fc","type":"http in","z":"742c51ad.23eee8","name":"","url":"/publish.html","method":"get","upload":false,"swaggerDoc":"","x":213.5,"y":662.25,"wires":[["787898b4.a00908"]]},{"id":"787898b4.a00908","type":"template","z":"742c51ad.23eee8","name":"HTML","field":"payload","fieldType":"msg","format":"html","syntax":"plain","template":"<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\"/>\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\" />\n<title>QuickStart MQTT</title>\n<script src=\"//code.jquery.com/jquery-2.0.3.min.js\"></script>\n<link rel=\"stylesheet\" href=\"//code.jquery.com/mobile/1.3.2/jquery.mobile-1.3.2.min.css\" />\n<script src=\"//code.jquery.com/mobile/1.3.2/jquery.mobile-1.3.2.min.js\"></script>\n\n<script src=\"./mqttws31.js\"></script>\n<meta name=\"description\" content=\"IBM IoTF QuickStart にスマホのジャイロ情報をパブリッシュするサービス\"/>\n<meta name=\"keywords\" content=\"IBM, Bluemix, IoT, QuickStart\"/>\n\n<script type=\"text/javascript\">\nvar deviceid = null;\nvar devicetype = \"MyDevice\";\nvar eventtype = null;\nvar test = null;\nvar client;\nvar pubTopic = 'iot-2/evt/status/fmt/json';\nvar phoneData = {};\nphoneData.d = {};\n\nvar lat = null;\nvar lng = null;\nvar ac = null;\nvar acg = null;\nvar rot = null;\nvar ori = null;\n$(function(){\n\tgetDeviceId();\n\n\tif( window.DeviceMotionEvent ){\n\t    window.addEventListener( \"devicemotion\", deviceMotion );\n\t}\n\tif( window.DeviceOrientationEvent ){\n\t    window.addEventListener( \"deviceorientation\", deviceOrientation );\n\t}\n \n\t$('#frm').submit( function(){\n\t\tdeviceid = $('#deviceid').val();\n\t\tdevicetype = $('#devicetype').val();\n\t\teventtype = $('#eventtype').val();\n\n\t\treturn false;\n\t});\n\t\n\tvar clientID = \"d:quickstart:\" + devicetype + \":\" + deviceid;\n\tconsole.log( \"clientID=\" + clientID );\n\tclient = new Messaging.Client(\"quickstart.messaging.internetofthings.ibmcloud.com\", 443, clientID );\n\tclient.onConnectionLost = onConnectionLost;\n\tclient.connect({onSuccess: onConnect, onFailure: onConnectFailure, useSSL: true});\n});\n\nfunction deviceMotion( e ) {\n\te.preventDefault();\n\t//console.log( e );\n\t\n\tac = e.acceleration;\n\tacg = e.accelerationIncludingGravity;\n\trot = e.rotationRate;\n\t\n\tpublishMessage();\n}\n\nfunction deviceOrientation( e ) {\n\t//e.preventDefault();\n\t//console.log( e );\n\t\n\tvar tiltLR = e.gamma;\n\tvar tiltFB = e.beta;\n\tvar dir = e.alpha;\n\tori = {};\n\tori['tiltLR'] = tiltLR;\n\tori['tiltFB'] = tiltFB;\n\tori['dir'] = dir;\n\t\n\tpublishMessage();\n}\n\nfunction publishMessage(){\n\tif( deviceid != null ){\n\t\tvar d = {};\n\t\tif( lat != null ){\n\t\t\td['lat'] = lat;\n\t\t\t$('#lat').html( lat );\n\t\t}\n\t\tif( lng != null ){\n\t\t\td['lng'] = lng;\n\t\t\t$('#lng').html( lng );\n\t\t}\n\t\tif( ac != null ){\n\t\t\td['ac'] = ac;\n\t\t\t$('#ac_x').html( ac['x'] );\n\t\t\t$('#ac_y').html( ac['y'] );\n\t\t\t$('#ac_z').html( ac['z'] );\n\t\t}\n\t\tif( acg != null ){\n\t\t\td['acg'] = acg;\n\t\t\t$('#acg_x').html( acg['x'] );\n\t\t\t$('#acg_y').html( acg['y'] );\n\t\t\t$('#acg_z').html( acg['z'] );\n\t\t}\n\t\tif( rot != null ){\n\t\t\td['rot'] = rot;\n\t\t\t$('#rot_a').html( rot['alpha'] );\n\t\t\t$('#rot_b').html( rot['beta'] );\n\t\t\t$('#rot_g').html( rot['gamma'] );\n\t\t}\n\t\tif( ori != null ){\n\t\t\td['ori'] = ori;\n\t\t\t$('#ori_lr').html( ori['tiltLR'] );\n\t\t\t$('#ori_fb').html( ori['tiltFB'] );\n\t\t\t$('#ori_dir').html( ori['dir'] );\n\t\t}\n\t\t\n\t\tif( d ){\n\t\t\tphoneData.d = d;\n\t\t\tphoneData.publish();\n\t\t}\n\t}\n}\n\n\nfunction onConnect() {\n\tconsole.log(\"Connected\");\n}\n\nfunction onConnectFailure(error) {\n\tconsole.log(\"Connect Failed\");\n\tconsole.log(error.errorCode);\n\tconsole.log(error.errorMessage);\n}\n\nfunction onConnectionLost(response) {\n\tconsole.log(\"onConnectionLost\")\n\tif (response.errorCode !== 0) {\n\t\t\tconsole.log(\"onConnectionLost:\"+response.errorMessage);\n\t}\n\tclearInterval(msgInterval);\n\tclient.connect({onSuccess: onConnect,\n\t\t\t\t\tonFailure: onConnectFailure});\n}\n\n\nphoneData.toJson = function(){\n\treturn JSON.stringify( this );\n}\n\nphoneData.publish = function(){\n\tvar message = new Messaging.Message( phoneData.toJson() );\n\tmessage.destinationName = pubTopic;\n\tclient.send( message );\n}\n\n\nfunction getDeviceId(){\n\tvar did = null;\n\tcookies = document.cookie.split( \"; \" );\n\tfor( i = 0; i < cookies.length; i ++ ){\n\t\tstr = cookies[i].split( \"=\" );\n\t\tif( unescape( str[0] ) == \"deviceid\" ){\n\t\t\tdid = unescape( unescape( str[1] ) );\n\t\t}\n\t}\n\t\n\tif( did != null ){\n\t\tdeviceid = did;\n\t}else{\n\t\tdeviceid = generateDeviceId();\n\t\t//console.log( \"deviceid = \" + deviceid );\n\t}\n\t$('#deviceid').html( deviceid );\n\tdocument.title = deviceid;\n}\n\nfunction generateDeviceId(){\n\tvar did = \"\";\n\tvar hx = \"0123456789abcdef\";\n\tfor( i = 0; i < 12; i ++ ){\n\t\tvar n = Math.floor( Math.random() * 16 );\n\t\tif( n == 16 ){ n = 15; }\n\t\tc = hx.charAt( n );\n\t\tdid += c;\n\t}\n\t\n\tvar str = \"deviceid=\" + did;\n\tdocument.cookie = str;\n\t\n\treturn did;\n}\n</script>\n\n</head>\n<body>\n\n<div id=\"page0\" data-role=\"page\">\n <div data-role=\"header\" data-position=\"fixed\">\n  <h1 id=\"deviceid\">************</h1>\n </div>\n \n <div data-role=\"content\">\n  <table border=\"1\" cellspacing=\"0\" data-theme=\"c\" width=\"100%\">\n   <thead>\n    <tr><th width=\"50%\">Keys</th><th>Values</th></tr>\n   </thead>\n   <tbody>\n    <tr><td>Lat</td><td id=\"lat\">&nbsp;</td></tr>\n    <tr><td>Lng</td><td id=\"lng\">&nbsp;</td></tr>\n    <tr><td>Acceleration.X</td><td id=\"ac_x\">&nbsp;</td></tr>\n    <tr><td>Acceleration.Y</td><td id=\"ac_y\">&nbsp;</td></tr>\n    <tr><td>Acceleration.Z</td><td id=\"ac_z\">&nbsp;</td></tr>\n    <tr><td>Acceleration(Gravity).X</td><td id=\"acg_x\">&nbsp;</td></tr>\n    <tr><td>Acceleration(Gravity).Y</td><td id=\"acg_y\">&nbsp;</td></tr>\n    <tr><td>Acceleration(Gravity).Z</td><td id=\"acg_z\">&nbsp;</td></tr>\n    <tr><td>Rotate.A</td><td id=\"rot_a\">&nbsp;</td></tr>\n    <tr><td>Rotate.B</td><td id=\"rot_b\">&nbsp;</td></tr>\n    <tr><td>Rotate.G</td><td id=\"rot_g\">&nbsp;</td></tr>\n    <tr><td>Orientation.LR</td><td id=\"ori_lr\">&nbsp;</td></tr>\n    <tr><td>Orientation.FB</td><td id=\"ori_fb\">&nbsp;</td></tr>\n    <tr><td>Orientation.DIR</td><td id=\"ori_dir\">&nbsp;</td></tr>\n   </tbody>\n  </table>\n </div>\n</div>\n\n</body>\n</html>\n","output":"str","x":410,"y":680,"wires":[["3704e77d.f08108"]]},{"id":"3704e77d.f08108","type":"http response","z":"742c51ad.23eee8","name":"","statusCode":"","headers":{},"x":570,"y":720,"wires":[]},{"id":"6146900e.3fb0a","type":"websocket out","z":"742c51ad.23eee8","name":"","server":"5eb26b59.51e10c","client":"","x":464.5,"y":847.5,"wires":[]},{"id":"ea94dbb1.eb3338","type":"ibmiot in","z":"742c51ad.23eee8","authentication":"quickstart","apiKey":"","inputType":"evt","deviceId":"","applicationId":"","deviceType":"+","eventType":"+","commandType":"","format":"json","name":"IBM IoT","service":"quickstart","allDevices":"","allApplications":"","allDeviceTypes":true,"allEvents":true,"allCommands":"","allFormats":"","qos":0,"x":173.5,"y":817.25,"wires":[["6146900e.3fb0a","b1d31481.e56fb8"]]},{"id":"b1d31481.e56fb8","type":"debug","z":"742c51ad.23eee8","name":"","active":true,"console":"false","complete":"false","x":349.5,"y":778.5,"wires":[]},{"id":"5eb26b59.51e10c","type":"websocket-listener","z":"","path":"/ws/sensor","wholemsg":"false"}]
